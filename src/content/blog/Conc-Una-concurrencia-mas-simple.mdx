---
heroImage: /src/assets/images/conc_article.png
category: Desarrollo de software
description: >-
  "Conc" es un pkg de Go en desarrollo que me tiene bastante emocionado, es un
  paquete que tiene como objetivo hacer la concurrencia incluso mas simple de lo
  que ya es en Go.
pubDate: 2024-02-23T05:00:00.000Z
tags:
  - Experimentos
  - Concurrencia
  - Golang
  - Go
title: 'Conc: Una concurrencia mas simple'
---

"[Conc](https://github.com/sourcegraph/conc)" es un pkg de Go en desarrollo que me tiene bastante emocionado, es un paquete que tiene como objetivo hacer la concurrencia incluso mÃ¡s simple de lo que ya es en Go.

En Go ya de por sÃ­ es bastante fÃ¡cil implementar concurrencia, sobre todo comparÃ¡ndolo con otros lenguajes, asÃ­ que es sorprendente cuando salen en el mar de paquetes de Go, un paquete que tiene como objetivo hacer una concurrencia mÃ¡s simple, segura y fÃ¡cil de mantener.

EstÃ¡ pensado, construido y mantenido por los genios de Sourcegraph, la versiÃ³n estable estÃ¡ en desarrollo, asÃ­ que verificarÃ­a mÃºltiples veces antes de utilizarla en un proyecto en producciÃ³n.

## ReducciÃ³n de boilerplate

Si has escrito concurrencia en Go, sabrÃ¡s que hay cierto boilerplate que tienes que seguir, y en ciertas ocasiones puede ser engorroso y feo de mantener (It's not big deal, but who cares ðŸ™‡ðŸ»â€â™‚ï¸), con Conc puedes hacer cosas simples como lo siguiente:

Imagina que tienes una funciÃ³n que necesites hacer concurrente muchas veces, en mi caso una funciÃ³n de test que tiene la probabilidad de tirar un panic o simplemente esperar cierto tiempo

```go
func thisIsSomethingYouShouldDoConcurrently() {
	chanceToPanic := rand.Intn(1000)
	if chanceToPanic > 603 && chanceToPanic < 760 {
		panic("I panicked!")
	}

	rSeconds := rand.Intn(14) + 2
	duration := time.Duration(rSeconds) * time.Second
	fmt.Print("I haven't panicked, so im sleeping for ", rSeconds, " seconds\n")
	time.Sleep(duration)
}

```

Con el pkg de sync, harÃ­amos lo siguiente para correr esta funciÃ³n al menos 100 veces:

```go
var wg sync.WaitGroup
for i := 0; i < 100; i++ {
  wg.Add(1)
  go func() {
    defer wg.Done()
    thisIsSomethingYouShouldDoConcurrently()
  }()
}
wg.Wait()
```

Nueve lÃ­neas de cÃ³digo para hacerlo, ahora veamos como podemos hacer lo mismo con Conc

```go
var wg conc.WaitGroup
for i := 0; i < 100; i++ {
  wg.Go(thisIsSomethingYouShouldDoConcurrently)
}
wg.Wait()
```

Es mucho mÃ¡s conciso, entendible y a primera vista no sorprende ni cansa tanto.

### Manejo de panics

La reducciÃ³n de boilerplate no es lo Ãºnico que te provee el waitGroup de Conc, tambiÃ©n maneja los panics que se producen dentro de las goroutines y espera primero a que todas terminen para poder propagar el panic, esto es especialmente Ãºtil en situaciones donde no quieres perder la ejecuciÃ³n del resto de goroutines por un panic en alguna de ellas. AdemÃ¡s, agrega un stacktrace completo de principio a fin de donde se ejecuta el panic.

En el repo nos ponen un ejemplo de como lograr esto mismo sin el paquete Conc:

```go
type caughtPanicError struct {
    val   any
    stack []byte
}

func (e *caughtPanicError) Error() string {
    return fmt.Sprintf(
        "panic: %q\n%s",
        e.val,
        string(e.stack)
    )
}

func main() {
    done := make(chan error)
    go func() {
        defer func() {
            if v := recover(); v != nil {
                done <- &caughtPanicError{
                    val: v,
                    stack: debug.Stack()
                }
            } else {
                done <- nil
            }
        }()
        doSomethingThatMightPanic()
    }()
    err := <-done
    if err != nil {
        panic(err)
    }
}
```

Un montÃ³n, Â¿No?

## Consideraciones

- SÃ­, obvio es un wrapper de [sync](https://pkg.go.dev/sync), pero es una buena abstracciÃ³n. Todo lo mismo que te da el paquete lo puedes lograr con cÃ³digo nativo de Go sin ninguna dependencia, pero el mundo del desarrollo de software estÃ¡ hecho a punta de tradeoffs entre simplicidad, tiempo de desarrollo y devexp.
- El manejo de los pools por Conc es maravilloso, te invito a que le des una mirada a todos los ejemplos en su repositorio: [https://github.com/sourcegraph/conc](https://github.com/sourcegraph/conc)
- No lo recomendarÃ­a como reemplazo directo de la concurrencia nativa de Go, Conc viene a resolver problemas que usualmente con pocas goroutines no encontraras.
- Es un paquete en desarrollo, puede cambiar mucho en el futuro, como mencionÃ© al principio del artÃ­culo, es un pkg del que estoy muy pendiente (y emocionado).
- Si eres principiante en Go, te recomiendo directamente olvidarte de la existencia de este pkg, ademÃ¡s de que viene a resolver problemas poco comunes, siempre es bueno tener las bases de lo que haces bien claras, o traerÃ¡s mÃ¡s problemas de los que solucionas.
