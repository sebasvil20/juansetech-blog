---
heroImage: /src/assets/images/gopher-gotham.png
category: Desarrollo de software
description: >-
  Descubre los secretos de la inyecciÃ³n de dependencias en tu aplicaciÃ³n Go.
  Este post te guiarÃ¡ a travÃ©s de diversas alternativas, permitiÃ©ndote comparar
  y elegir la mejor opciÃ³n para tu proyecto. Optimiza tu cÃ³digo y lleva tu
  desarrollo en Go al siguiente nivel. Â¡No te pierdas esta guÃ­a esencial!
pubDate: 2023-11-23T05:00:00.000Z
draft: false
tags:
  - '#Backend'
  - '#DI'
  - '#Golang'
  - '#Go'
title: Como hacer inyecciÃ³n de dependencias en Go
---

Â¿Cansado de depender de variables globales para arrancar tu logger? Â¿Deseas garantizar que todas tus capas se inicialicen en un Ãºnico lugar y solo una vez? Â¿Utilizas interfaces y structs para definir tus mÃ³dulos, pero te enfrentas al desafÃ­o de pasar dependencias inicializadas entre ellos? PrepÃ¡rate, porque en este artÃ­culo exploraremos diversas estrategias para la inyecciÃ³n de dependencias en Go. Desde enfoques sin librerÃ­as hasta aquellos que las incorporan, descubrirÃ¡s los pros y contras de cada uno. Â¡Es hora de optimizar tu cÃ³digo y elevar tus habilidades en Go al siguiente nivel!

## InyecciÃ³n de dependencias sin librerÃ­as en Go:

Para lograr hacer inyecciÃ³n de dependencias en Go sin librerÃ­as debemos tener en cuenta que para lograr esto es necesario el uso de interfaces y structs para la definiciÃ³n de cada uno de tus mÃ³dulos, esto va a ser especÃ­ficamente Ãºtil al momento de testear toda tu aplicaciÃ³n. La lÃ³gica es simple, una funciÃ³n `New...()` o `Provide...()` que cree una instancia de tu mÃ³dulo e inicializarlos luego en algÃºn fichero central de tu aplicaciÃ³n.

VeÃ¡moslo con un ejemplo, una API de libros bÃ¡sica con una db mockeada. Tenemos un controlador, un servicio y un repositorio, cada uno necesita del otro (dependencias), por ejemplo el controlador necesita un servicio y el servicio necesita un repositorio. Let's dig into code.

_Disclaimer: En estos ejemplos utilizo [Gin Gonic ](https://github.com/gin-gonic/gin 'Gin Gonic')para el servidor web, pero todos son realizables y adaptables para el framework/router que utilices ğŸ˜„_

`book_repository.go`

```go
type IBookRepository interface {
	GetBook(ctx context.Context, id string) (any, error)
}

type BookRepository struct {
	DBMock map[string]any
}

func (repo *BookRepository) GetBook(ctx context.Context, id string) (any, error) {
	book, ok := repo.DBMock[id]
	if !ok {
		return nil, errors.New("no books found")
	}

	return book, nil
}

```

`book_service.go`

```go
type IBookService interface {
  GetBook(ctx context.Context, id string)(any, error)
}

type BookService struct {
	BookRepository repository.IBookRepository
}

func(srv * BookService) GetBook(ctx context.Context, id string)(any, error) {
  return srv.BookRepository.GetBook(ctx, id)
}
```

`book_controller.go`

```go
type IBooksController interface {
	GetBook(c *gin.Context)
}

type BooksController struct {
	BooksService service.IBookService
}

func (ctrl *BooksController) GetBook(c *gin.Context) {
	book, err := ctrl.BooksService.GetBook(c, c.Param("id"))
	if err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
		return
	}
	c.JSON(http.StatusOK, book)
}
```

Una forma fÃ¡cil para inicializar y pasar todas las dependencias necesarias puede ser en el `main.go`, de la siguiente forma:

```go
func main() {
	bookRepo := repository.BookRepository{DBMock: map[string]any{}}
	bookSrv := service.BookService{BookRepository: &bookRepo}
	bookCtrl := controller.BooksController{BooksService: &bookSrv}

	r := gin.Default()
	r.GET("/books", bookCtrl.GetBook)
	r.Run()
}
```

Debes notar el orden en el que deben ser inicializados, de la dependencia mÃ¡s profunda a la mÃ¡s superficial.

Esto es perfecto si tienes un proyecto pequeÃ±o, pero entre mÃ¡s crezca vas a "ensuciar" mÃ¡s tu `main.go`, que deberÃ­a ser solo el punto de entrada y no contener nada mÃ¡s, Â¿cÃ³mo mejoramos este cÃ³digo?

Podemos crear funciones para inicializar cada una de las dependencias, llamÃ¡ndolas `New...()` o `Provide...()` y moviÃ©ndolas a un nuevo file que se encargue de manejar todas tus dependencias.

En mi caso lo movÃ­ a un mÃ³dulo llamado app y cree el file `app.go` que contiene la funciÃ³n `Run()` que inicializa todas las dependencias e inicializa el servidor.

```go
func Run() {
  bookRepo:= providers.ProvideBookRepository()
  bookService:= providers.ProvideBookService(bookRepo)
  bookController:= providers.ProvideBookController(bookService)
  router:= HttpRouter(bookController)
  router.Run(":8080")
}

```

La estructura de archivos de este proyecto es la siguiente en este punto:

```markdown
.
â”œâ”€â”€ ğŸ“ src  
â”‚ â””â”€â”€ ğŸ“ app InyecciÃ³n de dependencias e inicializadores de la app.
â”‚ â””â”€â”€ ğŸ“ providers Proveedores(funciones que inicializan structs) de todos los mÃ³dulos.
â”‚ â”‚ â””â”€â”€ ğŸ“„ controllers.go
â”‚ â”‚ â””â”€â”€ ğŸ“„ services.go
â”‚ â”‚ â””â”€â”€ ğŸ“„ repositories.go
â”‚ â””â”€â”€ ğŸ“„ app.go AcÃ¡ va la funciÃ³n Run() que llama a todos los proveedores e inicializa el servidor.
â”‚ â””â”€â”€ ğŸ“„ router.go ConfiguraciÃ³n y ruteo del servidor web.
â”‚ â””â”€â”€ ğŸ“ controller Controladores que reciben las requests.
â”‚ â””â”€â”€ ğŸ“ service LÃ³gica de negocio, modificaciones de modelos, etc.
â”‚ â””â”€â”€ ğŸ“ repository Capa que accede a los datos.
â”‚ â””â”€â”€ ğŸ“„ main.go Llama a app.Run().
â””â”€â”€
```
