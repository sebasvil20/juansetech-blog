---
heroImage: /src/assets/images/gopher-gotham.png
category: Desarrollo de software
description: >-
  Descubre los secretos de la inyecci√≥n de dependencias en tu aplicaci√≥n Go.
  Este post te guiar√° a trav√©s de diversas alternativas, permiti√©ndote comparar
  y elegir la mejor opci√≥n para tu proyecto. Optimiza tu c√≥digo y lleva tu
  desarrollo en Go al siguiente nivel. ¬°No te pierdas esta gu√≠a esencial!
pubDate: 2024-01-05T05:00:00.000Z
draft: false
tags:
  - '#Backend'
  - '#DI'
  - '#Golang'
  - '#Go'
title: Como hacer inyecci√≥n de dependencias en Go
---

¬øCansado de depender de variables globales para arrancar tu logger? ¬øDeseas garantizar que todas tus capas se inicialicen en un √∫nico lugar y solo una vez? ¬øUtilizas interfaces y structs para definir tus m√≥dulos, pero te enfrentas al desaf√≠o de pasar dependencias inicializadas entre ellos? En este art√≠culo exploraremos diversas estrategias para la inyecci√≥n de dependencias en Go. Desde enfoques sin librer√≠as hasta aquellos que las incorporan, descubrir√°s los pros y contras de cada uno.

## ¬øPor qu√© hacer inyecci√≥n de dependencias en Go?

La inyecci√≥n de dependencias en Go ofrece una metodolog√≠a eficaz para mejorar la modularidad y mantenibilidad del c√≥digo. Al evitar el uso de variables globales, promueve un dise√±o m√°s limpio y cohesivo, facilitando la comprensi√≥n y modificaci√≥n del c√≥digo. Adem√°s, proporciona una mayor testabilidad al permitir la sustituci√≥n sencilla de dependencias durante las pruebas unitarias, favoreciendo el desarrollo de software robusto y libre de acoplamientos innecesarios. La inyecci√≥n de dependencias tambi√©n fomenta la reutilizaci√≥n de componentes, al facilitar la conexi√≥n de m√≥dulos sin depender de implementaciones concretas.

## Inyecci√≥n de dependencias sin librer√≠as en Go:

Para lograr hacer inyecci√≥n de dependencias en Go sin librer√≠as debemos tener en cuenta que es necesario el uso de interfaces y structs para la definici√≥n de cada uno de tus m√≥dulos, esto va a ser espec√≠ficamente √∫til al momento de testear toda tu aplicaci√≥n. La l√≥gica es simple, una funci√≥n `New...()` o `Provide...()` que cree una instancia de tu m√≥dulo e inicializarlos luego en alg√∫n fichero central de tu aplicaci√≥n.

Ve√°moslo con un ejemplo, una API de libros b√°sica con una db mockeada. Tenemos un controlador, un servicio y un repositorio, cada uno necesita del otro (dependencias), por ejemplo el controlador necesita un servicio y el servicio necesita un repositorio. Let's dig into code.

_Disclaimer: En estos ejemplos utilizo [Gin Gonic ](https://github.com/gin-gonic/gin 'Gin Gonic')para el servidor web, pero todos son realizables y adaptables para el framework/router que utilices üòÑ_

`book_repository.go`

```go
type IBooksRepository interface {
	GetAll(ctx context.Context) ([]models.Book, error)
}

type BooksRepository struct {
	DB []models.Book
}

func (r *BooksRepository) GetAll(ctx context.Context) ([]models.Book, error) {
	return r.DB, nil
}

```

`book_service.go`

```go
type IBooksService interface {
	GetAll(ctx context.Context) ([]models.Book, error)
}

type BooksService struct {
	Repo repositories.IBooksRepository
}

func (s *BooksService) GetAll(ctx context.Context) ([]models.Book, error) {
	return s.Repo.GetAll(ctx)
}
```

`book_controller.go`

```go
type IBooksController interface {
	GetAll(c *gin.Context)
}

type BooksController struct {
	Service services.IBooksService
}

func (c *BooksController) GetAll(ctx *gin.Context) {
	books, _ := c.Service.GetAll(ctx)
	ctx.JSON(200, gin.H{
		"books": books,
	})
}
```

Una forma f√°cil para inicializar y pasar todas las dependencias necesarias puede ser en el `main.go`, de la siguiente forma:

```go
func main() {
	bookRepo := repositories.BooksRepository{DB: []models.Book{}}
	bookSrv := services.BooksService{Repo: &bookRepo}
	bookCtrl := controllers.BooksController{Service: &bookSrv}

	r := gin.Default()
	r.GET("/books", bookCtrl.GetAll)
	r.Run(":8080")
}
```

Debes notar el orden en el que deben ser inicializados, de la dependencia m√°s profunda a la m√°s superficial.

Esto es perfecto si tienes un proyecto peque√±o, pero entre m√°s crezca vas a "ensuciar" m√°s tu `main.go`, que deber√≠a ser solo el punto de entrada y no contener nada m√°s, ¬øc√≥mo mejoramos este c√≥digo?

Podemos crear funciones para inicializar cada una de las dependencias, llam√°ndolas `New...()` o `Provide...()` y movi√©ndolas a un nuevo file que se encargue de manejar todas tus dependencias.

En mi caso lo mov√≠ a un m√≥dulo llamado app y cree el file `app.go` que contiene la funci√≥n `Run()` que inicializa todas las dependencias e inicializa el servidor. Las funciones que inicializan las dependencias las mov√≠ para un pkg llamado `providers`.

```go
func Run() {
  mockedDB:= providers.ProvideDatabase()
	bookRepo:= providers.ProvideBooksRepository(mockedDB)
	bookService:= providers.ProvideBooksService(bookRepo)
	bookController:= providers.ProvideBooksController(bookService)
	router := providers.ProvideRouter()
	providers.RegisterRoutes(router, bookController)
	router.Run(":8080")
}

```

La estructura de archivos de este proyecto es la siguiente en este punto:

```markdown
.
‚îú‚îÄ‚îÄ üìÅ src  
‚îÇ ‚îî‚îÄ‚îÄ üìÅ app Inyecci√≥n de dependencias e inicializadores de la app.
‚îÇ ‚îî‚îÄ‚îÄ üìÅ providers Proveedores(funciones que inicializan structs) de todos los m√≥dulos.
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ üìÑ controllers.go
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ üìÑ services.go
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ üìÑ repositories.go
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ üìÑ router.go Funciones relacionadas al routero de la API.
‚îÇ ‚îî‚îÄ‚îÄ üìÑ app.go Ac√° va la funci√≥n Run() que llama a todos los proveedores e inicializa el servidor.
‚îÇ ‚îî‚îÄ‚îÄ üìÑ router.go Configuraci√≥n y ruteo del servidor web.
‚îÇ ‚îî‚îÄ‚îÄ üìÅ controller Controladores que reciben las requests.
‚îÇ ‚îî‚îÄ‚îÄ üìÅ service L√≥gica de negocio, modificaciones de modelos, etc.
‚îÇ ‚îî‚îÄ‚îÄ üìÅ repository Capa que accede a los datos.
‚îÇ ‚îî‚îÄ‚îÄ üìÑ main.go Llama a app.Run().
‚îî‚îÄ‚îÄ
```

El repositorio con todos los archivos lo tienes ac√°: [sebasvil20/blog-di](https://github.com/sebasvil20/blog-di 'sebasvil20/blog-di')

Con esto, deber√°s tener una API corriendo en el puerto _8080_ que cuando le pegas al endpoint `GET /books` vas a recibir una lista en json con dos libros:

```javascript
{"books":[{"id":1,"title":"El se√±or de los anillos","author":"J.R.R. Tolkien"},{"id":2,"title":"Cien a√±os de soledad","author":"Gabriel Garc√≠a M√°rquez"}]}
```

Y eso ser√≠a de la inyecci√≥n de dependencias manual, como puedes ver, es bastante simple y f√°cil de seguir, pero tiene un problema: cuando el proyecto crece se puede volver dif√≠cil de controlar y mantener, pasemos a ver m√°s alternativas para hacer inyecci√≥n de dependencias en Go.

## DI con Uber/fx: Inyecci√≥n de dependencias con fx

Reutilizaremos la mayor√≠a del c√≥digo del ejemplo pasado, solo cambiaremos las partes de la inyecci√≥n de dependencias. Te dejo el repositorio con todos los ejemplos nuevamente: [sebasvil20/blog-di](https://github.com/sebasvil20/blog-di 'sebasvil20/blog-di').

Toda la documentaci√≥n de uber fx y su repo: [https://github.com/uber-go/fx](https://github.com/uber-go/fx)

Como paso principal, para instalar _uber/fx_ corres el siguiente comando:

```
go get go.uber.org / fx@v1
```

La l√≥gica inicial es la misma que con la inyecci√≥n manual de dependencias: Debes tener todo estructurado en interfaces y structs, una vez tengas bien definidas estas cosas, pasemos a lo especifico de Uber FX:

Lo primero que debemos entender es que uber FX inyecta las dependencias en tiempo de ejecuci√≥n, y te da control sobre el ciclo de vida de tu aplicaci√≥n, por ejemplo, que quieres hacer una vez se inicialicen tus dependencias o que quieres hacer una vez la app muera, esto es √∫til para casos donde necesitemos hacer _cleanup_ de una base de datos por ejemplo.

Adem√°s del ciclo de vida, te deja organizar tus dependencias en "M√≥dulos" que no son m√°s que grupos de dependencias, as√≠ definimos un m√≥dulo para fx (En la carpeta pkg de `providers` cree un file llamado `books_module`):

```go

var BooksModule = fx.Module("Books",
	fx.Provide(func(db []models.Book) repositories.IBooksRepository {
		return &repositories.BooksRepository{
			DB: db,
		}
	}),

	fx.Provide(func(repo repositories.IBooksRepository) services.IBooksService {
		return &services.BooksService{
			Repo: repo,
		}
	}),

	fx.Provide(func(srv services.IBooksService) *controllers.BooksController {
		return &controllers.BooksController{
			Service: srv,
		}
	}),
)

```

`fx.Module` recibe tanto el nombre del m√≥dulo como las funciones propias de fx como **`fx.Provide`** o `fx.Invoke`, el nombre del m√≥dulo sirve √∫nicamente para loggear y hacer troubleshooting, lo vas a ver cuando inicialices la app.

`fx.Provide` es una funci√≥n que como su nombre indica, provee, esta la debes usar cuando el return de esa funci√≥n lo van a usar en otras funciones, por ejemplo el servicio de libros, `services.IBookService`, lo va a usar el controller para inyect√°rselo, por eso usamos `fx.Provide`.

`fx.Invoke` invoca funciones que no necesariamente lo que devuelven lo vamos a usar, pueden devolver un error (fx los maneja autom√°ticamente si una de estas devuelve error). Esta funci√≥n es perfecta para decorar cosas o simplemente inicializar algo que no devuelve nada.

Ahora en el `app.go` podemos llamar al m√≥dulo e inicializar el resto de cosas que necesitemos. Adem√°s, como mencion√© anteriormente, fx te deja controlar el ciclo de vida de las dependencias y es al menos necesario que definas el hook `onStart`. El archivo `app.go` quedar√≠a as√≠:

```go

func Run() {
  fx.New(
    fx.Provide(providers.ProvideDatabase),
    providers.BooksModule,
    fx.Provide(providers.ProvideRouter),
    fx.Invoke(providers.RegisterRoutes),
    fx.Invoke(serve),
  ).Run()
}

func serve(lifecycle fx.Lifecycle, router * gin.Engine) {
  lifecycle.Append(fx.Hook{
    OnStart: func(context.Context) error {
    go router.Run()
			return nil
  },
	})
}

```

La funci√≥n `Run()` es la que creamos nosotros, ac√° invocamos e inicializamos todas las dependencias.

Primero creamos una instancia de fx con `fx.New()` que recibe tantos par√°metros (de tipo `fx.Option`) como necesites. N√≥tese que en los casos de los m√≥dulos solo hacemos referencia al m√≥dulo, ya que adentro del m√≥dulo llamamos a `fx.Provide` para las dependencias. Adem√°s, n√≥tese la invocaci√≥n (`fx.Invoke`) de la funci√≥n `serve`, que recibe el ciclo de vida de fx y m√°s par√°metros que requieras, el resto de par√°metros fx los resuelve autom√°ticamente, tomando los return values de los `fx.Provide`.

En la funci√≥n `serve` le sumamos un item al ciclo de vida de fx con `lifecycle.Append` y le pasamos el hook que queremos, en nuestro caso queremos que cuando ya termine de resolver las dependencias, llame al router de gin e inicialice el servidor.

Nuestro `main.go` queda igual que en la anterior, solamente llamamos al `app.Run()`

```go
func main() {
  app.Run()
}
```

Con esto deber√≠as tener un servidor corriendo en el 8080 recibiendo peticiones correctamente, adem√°s con dependencias resueltas por uber fx.

El ejemplo completo por si quieres probar directamente lo encuentras en el repo: [sebasvil20/blog-di](https://github.com/sebasvil20/blog-di 'sebasvil20/blog-di').

Hey! üòÅ ¬°Has llegado al final! Si te ha gustado el art√≠culo o te ha sido √∫til, no dudes en compartirlo, puedes decirme tus opiniones a trav√©s de mi cuenta de [X / Twitter.](https://twitter.com/JuanseTech 'X / Twitter')
