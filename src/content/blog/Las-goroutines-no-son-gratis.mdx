---
heroImage: /src/assets/images/gopher-friends.png
category: Desarrollo de software
description: >-
  Las goroutines no siempre podr铆an ser tu mejor opci贸n: en algunas ocasiones
  ser谩n tus enemigos. Si te preguntas por qu茅 tu c贸digo concurrente es m谩s lento
  que el c贸digo sin concurrencia, este es el art铆culo que lo explica.
pubDate: 2024-02-12T05:00:00.000Z
draft: false
tags:
  - Concurrency
  - Goroutines
  - Golang
  - Go
title: Las goroutines no son gratis
---

Las goroutines no siempre podr铆an ser tu mejor opci贸n: en algunas ocasiones ser谩n tus enemigos. Si te preguntas por qu茅 tu c贸digo concurrente es m谩s lento que el c贸digo sin concurrencia, este es el art铆culo que lo explica.

Siempre que vemos c贸digo que se bloquea en alg煤n momento, pensamos en hacerlo concurrente para mejorar los tiempos de respuesta y ejecuci贸n, pero a menudo se nos olvida que las goroutines no son gratis.

Agregar concurrencia a nuestra aplicaci贸n en Go involucra tiempo extra al iniciar goroutines, manejar channels y hacer el cleanup, por lo que debemos siempre hacer benchmarking antes de elegir si debemos o no hacer el c贸digo concurrente.

## Benchmarking de c贸digo sin goroutines

Vamos a mirar un ejemplo, una funci贸n que: Le pasas un n煤mero y hace las sumas de todos los n煤meros hasta ese n煤mero y adem谩s hace multiplicaciones de ese n煤mero hacia abajo, veamos la funci贸n:

```go
func SumUpToAndMultiplyDownTo(n int) (totalUp, totalDown int) {
	for i := 1; i <= n; i++ {
		totalUp += i
	}

	for i := n; i > 0; i-- {
		totalDown *= i
	}

	return
}
```

En este c贸digo vemos lo que mencionaba al principio: El primer for bloquea la ejecuci贸n del segundo hasta que termine, y el segundo bloquea el return hasta que termine sus iteraciones.

Nuestro primer pensamiento para mejorar esto, es meter goroutines, una por cada for y as铆 que se ejecuten concurrentemente, antes de eso, veamos benchmarks de la funci贸n sin goroutines con varios inputs:

```
Benchmark_SumUpToAndMultiplyDownToN/size_10-8         	135480042	      8.625 ns/op
Benchmark_SumUpToAndMultiplyDownToN/size_100-8        	15683214	      73.73 ns/op
Benchmark_SumUpToAndMultiplyDownToN/size_1000-8       	 2006463	      597.6 ns/op
Benchmark_SumUpToAndMultiplyDownToN/size_10000-8      	  208394	      5754 ns/op
Benchmark_SumUpToAndMultiplyDownToN/size_100000-8     	   20874	      57880 ns/op
Benchmark_SumUpToAndMultiplyDownToN/size_1000000000-8 	     2	          582751048 ns/op
Benchmark_SumUpToAndMultiplyDownToN/size_100000000000-8      1	          58273409486 ns/op
```

Como vemos, cuando a la funci贸n le pasas diez como input, la funci贸n demora 8.625 ns, y, cuando a la funci贸n le pasas cien mil millones como input, la funci贸n demora en ejecutarse 58273409486 ns, lo que a segundos son 58.27s.

## Benchmarking de c贸digo con goroutines

Ahora hagamos el c贸digo concurrente, nuestra intuici贸n nos llevar谩 a que pensar que nuestro c贸digo demorar谩 la mitad, al hacer que los dos fors se ejecuten concurrentemente, pero no es del todo as铆. Veamos como queda la funci贸n.

```go
func SumUpToAndMultiplyDownTo(n int) (totalUp, totalDown int) {
	var wg sync.WaitGroup

	upChan := make(chan int)
	downChan := make(chan int)

	wg.Add(1)
	go func() {
		defer wg.Done()
		for i := 1; i <= n; i++ {
			totalUp += i
		}
		upChan <- totalUp
	}()

	wg.Add(1)
	go func() {
		defer wg.Done()
		result := 1
		for i := n; i > 0; i-- {
			result *= i
		}
		downChan <- result
	}()

	go func() {
		wg.Wait()
		close(upChan)
		close(downChan)
	}()

	totalUp = <-upChan
	totalDown = <-downChan

	return
}
```

Ahora, el benchmark nos tira resultados que van en contra de nuestra intuici贸n:

```go
Benchmark_SumUpToAndMultiplyDownToN/size_10-8         	  435163	      2465 ns/op
Benchmark_SumUpToAndMultiplyDownToN/size_100-8        	  429084	      2853 ns/op
Benchmark_SumUpToAndMultiplyDownToN/size_1000-8       	  217639	      5360 ns/op
Benchmark_SumUpToAndMultiplyDownToN/size_10000-8      	   47982	      24862 ns/op
Benchmark_SumUpToAndMultiplyDownToN/size_100000-8     	    5576	      214011 ns/op
Benchmark_SumUpToAndMultiplyDownToN/size_1000000000-8 	      1	          2155616959 ns/op
Benchmark_SumUpToAndMultiplyDownToN/size_100000000000-8       1	          213229888154 ns/op
```

## Resultados

La funci贸n con goroutines con diez como input, demora 2465 ns, eso son 285 veces m谩s que el c贸digo sin goroutines (que el resultado fueron 8.625 ns) く. Y cuando le pasas cien mil millones como input, el c贸digo con goroutines se demora 213229888154 ns (\~3.5 minutos) eso es 3.6 veces (aproximadamente) m谩s que el c贸digo sin goroutines.

## Disclaimer

El benchmark fue hecho con las siguientes caracter铆sticas:

```
goos: darwin
goarch: amd64
cpu: Intel(R) Core(TM) i7 - 1068NG7 CPU @2.30GHz
```

Aunque este ejemplo podr铆a ser algo dummy, puedes hacer la prueba del benchmark con otros ejemplos m谩s complejos.

## Conclusiones

- Las goroutines no son gratis, para inicializarlas, sincronizarlas y manejarlas, la app gasta recursos que, en ciertos casos, podr铆an ser incluso mayores que los de una funci贸n sin goroutines.
- Entre m谩s tiempo demoren las tareas bloqueantes, podr铆a ser mejor opci贸n utilizar goroutines.
- En casos donde las tareas bloqueantes tarden relativamente poco, es mejor que se ejecute el c贸digo linealmente en vez de concurrentemente.
- Siempre realiza benchmarks sobre tu c贸digo con ambas opciones, para comprobar con resultados num茅ricos cu谩l es la mejor opci贸n para tu caso. No te dejes llevar por tu intuici贸n.
